<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Systems and Queries - Understanding Bevy</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../ecs/_index.html"><strong aria-hidden="true">2.</strong> Entities, Components and Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ecs/entities-components.html"><strong aria-hidden="true">2.1.</strong> Entities and Components</a></li><li class="chapter-item expanded "><a href="../ecs/systems-queries.html" class="active"><strong aria-hidden="true">2.2.</strong> Systems and Queries</a></li><li class="chapter-item expanded "><a href="../ecs/resources.html"><strong aria-hidden="true">2.3.</strong> Resources</a></li><li class="chapter-item expanded "><a href="../ecs/commands.html"><strong aria-hidden="true">2.4.</strong> Commands</a></li><li class="chapter-item expanded "><a href="../ecs/timing/_index.html"><strong aria-hidden="true">2.5.</strong> Control Flow and Timing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ecs/timing/scheduling-stages.html"><strong aria-hidden="true">2.5.1.</strong> System Scheduling and Stages</a></li><li class="chapter-item expanded "><a href="../ecs/communication/conditional-systems.html"><strong aria-hidden="true">2.5.2.</strong> Run Criteria and States</a></li><li class="chapter-item expanded "><a href="../ecs/timing/timers.html"><strong aria-hidden="true">2.5.3.</strong> Timers and Time Steps</a></li></ol></li><li class="chapter-item expanded "><a href="../ecs/communication/_index.html"><strong aria-hidden="true">2.6.</strong> Tools for Intersystem Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ecs/communication/events.html"><strong aria-hidden="true">2.6.1.</strong> Events</a></li><li class="chapter-item expanded "><a href="../ecs/communication/chaining.html"><strong aria-hidden="true">2.6.2.</strong> Chaining Systems</a></li></ol></li><li class="chapter-item expanded "><a href="../ecs/internals/_index.html"><strong aria-hidden="true">2.7.</strong> ECS Internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ecs/internals/app-builder.html"><strong aria-hidden="true">2.7.1.</strong> App Builder</a></li><li class="chapter-item expanded "><a href="../ecs/internals/world.html"><strong aria-hidden="true">2.7.2.</strong> World</a></li><li class="chapter-item expanded "><a href="../ecs/internals/default-plugins.html"><strong aria-hidden="true">2.7.3.</strong> Default Plugins</a></li><li class="chapter-item expanded "><a href="../ecs/internals/archetypes.html"><strong aria-hidden="true">2.7.4.</strong> Archetypes</a></li><li class="chapter-item expanded "><a href="../ecs/internals/reflection.html"><strong aria-hidden="true">2.7.5.</strong> Reflection</a></li><li class="chapter-item expanded "><a href="../ecs/internals/tasks.html"><strong aria-hidden="true">2.7.6.</strong> Tasks</a></li></ol></li><li class="chapter-item expanded "><a href="../ecs/think-ecs.html"><strong aria-hidden="true">2.8.</strong> Think ECS: Idiomatic Problem Solving in Bevy</a></li></ol></li><li class="chapter-item expanded "><a href="../organization/_index.html"><strong aria-hidden="true">3.</strong> Organizing Your Bevy Codebase</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../organization/project-structure.html"><strong aria-hidden="true">3.1.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="../organization/plugins.html"><strong aria-hidden="true">3.2.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="../organization/scenes.html"><strong aria-hidden="true">3.3.</strong> Scenes</a></li></ol></li><li class="chapter-item expanded "><a href="../serialization/_index.html"><strong aria-hidden="true">4.</strong> Serialization and Networking</a></li><li class="chapter-item expanded "><a href="../graphics/_index.html"><strong aria-hidden="true">5.</strong> Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../graphics/assets-sprites.html"><strong aria-hidden="true">5.1.</strong> Assets and Sprites</a></li><li class="chapter-item expanded "><a href="../graphics/transforms.html"><strong aria-hidden="true">5.2.</strong> Transforms</a></li><li class="chapter-item expanded "><a href="../graphics/cameras.html"><strong aria-hidden="true">5.3.</strong> Cameras</a></li><li class="chapter-item expanded "><a href="../graphics/children.html"><strong aria-hidden="true">5.4.</strong> Hierarchy: Parents and Children</a></li><li class="chapter-item expanded "><a href="../graphics/animation.html"><strong aria-hidden="true">5.5.</strong> Animation</a></li><li class="chapter-item expanded "><a href="../graphics/meshes.html"><strong aria-hidden="true">5.6.</strong> Meshes</a></li><li class="chapter-item expanded "><a href="../graphics/shaders.html"><strong aria-hidden="true">5.7.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="../graphics/vector_graphics.html"><strong aria-hidden="true">5.8.</strong> Vector Graphics</a></li></ol></li><li class="chapter-item expanded "><a href="../ui/_index.html"><strong aria-hidden="true">6.</strong> User Interfaces</a></li><li class="chapter-item expanded "><a href="../audio/_index.html"><strong aria-hidden="true">7.</strong> Audio</a></li><li class="chapter-item expanded "><a href="../input/_index.html"><strong aria-hidden="true">8.</strong> Input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../input/keyboard.html"><strong aria-hidden="true">8.1.</strong> Keyboard</a></li><li class="chapter-item expanded "><a href="../input/mouse.html"><strong aria-hidden="true">8.2.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="../input/controller.html"><strong aria-hidden="true">8.3.</strong> Controller</a></li><li class="chapter-item expanded "><a href="../input/touch.html"><strong aria-hidden="true">8.4.</strong> Touch</a></li></ol></li><li class="chapter-item expanded "><a href="../physics/_index.html"><strong aria-hidden="true">9.</strong> Physics</a></li><li class="chapter-item expanded "><a href="../development/_index.html"><strong aria-hidden="true">10.</strong> Productive Development in Bevy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../development/compiling.html"><strong aria-hidden="true">10.1.</strong> Compiling your Game</a></li><li class="chapter-item expanded "><a href="../development/testing.html"><strong aria-hidden="true">10.2.</strong> Idiomatic Automated Testing</a></li><li class="chapter-item expanded "><a href="../development/diagnostics.html"><strong aria-hidden="true">10.3.</strong> Diagnostics and Debugging</a></li><li class="chapter-item expanded "><a href="../development/cross-platform.html"><strong aria-hidden="true">10.4.</strong> Cross-Platform Support</a></li><li class="chapter-item expanded "><a href="../development/releasing.html"><strong aria-hidden="true">10.5.</strong> Releasing your Game</a></li><li class="chapter-item expanded "><a href="../development/common-issues.html"><strong aria-hidden="true">10.6.</strong> Common Issues and Finding Help</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Understanding Bevy</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#systems-and-queries" id="systems-and-queries">Systems and Queries</a></h1>
<p>In Bevy, <strong>systems</strong> are the beating heart of your game: containing all of the necessary logic to actually <em>make stuff happen</em>.
Systems are ordinary (if constrained) Rust functions that you use by: </p>
<ol>
<li>Defining the function with the appropriate argument types.</li>
<li>Adding to your <code>AppBuilder</code> with functions like <code>.add_system</code>.</li>
</ol>
<p>Systems:</p>
<ol>
<li>Live within a <a href="timing/scheduling-stages.html">'Stage'</a>, which control the broad timing and scheduling strategy of the system.</li>
<li>Automatically run and supplied with data to read and write by Bevy's <a href="timing/scheduling-stages.html">scheduler</a>.</li>
</ol>
<p>Ordinary systems can accept any arguments that implement the <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.SystemParam.html"><code>SystemParam</code></a> trait. The typical built-in options for this are:</p>
<ol>
<li><strong>Queries</strong> (<code>Query</code>), which grab the components for all entities which have <em>all</em> of the specified components and pass the <strong>query filters</strong>.</li>
<li><strong>Resources</strong> (<code>Res</code>, <code>ResMut</code> and <code>Local</code>), which are global singletons for storing data that isn't associated with a particular entity.</li>
<li><strong>Commands</strong> (<code>Commands</code>), for queueing up broad-reaching tasks until the end of the stage. See <a href="communication/commands.html">Commands</a> for an explanation of how these work.</li>
<li><strong>System-chained arguments</strong> (<code>In</code>), which automatically fetch the output of the system that is configured to chain into them. These are less common, and are discussed in <a href="communication/chaining.html">Chaining Systems</a> instead.</li>
</ol>
<p>Thread-local systems (discussed below) have complete (but not parallelizable) access to our app's state. They accept <code>World</code> (which collects all of the entity + component data) and <code>Resources</code> arguments instead.</p>
<p>For simple projects, the most important distinction is between <strong>startup systems</strong> and ordinary systems. Startup systems run exactly once, before any ordinary systems run, while ordinary systems will run every tick.
We can add systems to our apps with the <a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.AppBuilder.html#method.add_system"><code>add_system</code></a> or <a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.AppBuilder.html#method.add_startup_system"><code>add_startup_system</code></a> methods.</p>
<p>In the following example, we take a look at the skeleton of a reasonably complete small game, to demonstrate how systems would actually be used:</p>
<pre><pre class="playground"><code class="language-rust">// In this example, we show the structure of a reasonably complex slime volleyball game
// Some of the details around handling graphics are omitted for brevity

use bevy::app::startup_stage;
use bevy::input::keyboard::KeyboardInput;
use bevy::prelude::*;

fn main() {
    App::build()
        .add_plugins(DefaultPlugins)
        // Startup systems are only run once
        .add_startup_system(setup_cameras.system())
        .add_resource(ArenaDimensions { x: 800.0, y: 600.0 })
        .add_startup_system(create_arena.system())
        // Ordinary systems run every frame
        .add_system(collisions.system())
        // We don't need a kinematics system: position and velocity are updated automatically
        // As long as we use Transform and include TransformPlugin from the DefaultPlugins
        // You can add multiple copies of the same function as different systems
        // System functions can be generic, allowing you to specialize behavior based on type
        .add_system(controls::&lt;Player1&gt;.system())
        .add_system(controls::&lt;Player2&gt;.system())
        // You can control when systems run by setting the Stage they are in
        // Every system in a Stage must complete before the scheduler can advance to the next
        // These are only in a separate stage for demonstration purposes
        .add_startup_system_to_stage(
            startup_stage::POST_STARTUP,
            create_slime::&lt;Player1&gt;.system(),
        )
        .add_startup_system_to_stage(
            startup_stage::POST_STARTUP,
            create_slime::&lt;Player2&gt;.system(),
        )
        .add_startup_system_to_stage(startup_stage::POST_STARTUP, create_ball.system())
        // We can modify our AppBuilder in whatever order we want
        // Although be careful because the methods are processed in order
        .init_resource::&lt;Score&gt;()
        .add_system(display_score.system())
        // We're passing information about a point being scored between our systems with an event
        .add_event::&lt;ScoreEvent&gt;()
        // We couldn't swap this line with the one above, because it relies on the Score resource
        .add_system_to_stage(stage::POST_UPDATE, check_for_points.system())
        // By moving this to a later stage, we can be sure that these runs after we finish checking for points
        .add_system_to_stage(stage::LAST, update_score.system())
        .add_system_to_stage(stage::LAST, reset_ball.system())
        .run();
}

fn setup_cameras(commands: &amp;mut Commands) {
    // Spawn a 2D camera with commands.spawn and Camera2dBundle

    // Spawn a UI camera with commands.spawn and CameraUiBundle
}

struct ArenaDimensions {
    x: f32,
    y: f32,
}

// This is a marker component to determine whether an object collides
struct Collides;

fn create_arena(commands: &amp;mut Commands, arena_dimensions: Res&lt;'_, &amp;'static ArenaDimensions&gt;) {
    // Read in the dimensions from our ArenaDimensions resource

    // Use commands.spawn and SpriteBundle to draw the arena
    // Also add a Collides marker component to the arena using .with
}

// We want to receive the Transform (i.e. a position, velocity etc.)
// for all objects that have the Collides marker component
// So we have a WorldQuery of Transform, and use a QueryFilter of With&lt;Collides&gt;
fn collisions(query: Query&lt;&amp;mut Transform, With&lt;Collides&gt;&gt;) {
    // Handle collisions and set new positions and velocities
}

// These are marker components to denote ownership of various objects
// If we had const generics, we could make this a struct that contained an integer instead :(
struct Player1;
struct Player2;

// Input handling in Bevy is done using Events
// We listen for the input events, then update the velocity of our slimes accordingly
// By making this function generic, we can ensure that players only control the correct slime
// We ensure that this function works for any generic type
// by adding the P: Component trait bound
fn controls&lt;P: Component&gt;(
    slime_query: Query&lt;&amp;mut Transform, (With&lt;Slime&gt;, With&lt;P&gt;)&gt;,
    mut input_event_reader: Local&lt;EventReader&lt;KeyboardInput&gt;&gt;,
    input_events: Res&lt;Events&lt;KeyboardInput&gt;&gt;,
) {
    // Read keyboard inputs

    // Apply the appropriate forces to the correct slime
}

// Another marker component
struct Slime;

// This function spawns a slime, under the control of the appropriate player
fn create_slime&lt;P: Component&gt;(commands: &amp;mut Commands) {
    // Use commands.spawn and SpriteBundle to draw each slime
    // Make sure to add all of the relevant marker components using .with:
    // Collides, Slime and the generic type P to denote which player it belongs to
}

// Yet another marker component!
struct Ball;

fn create_ball(commands: &amp;mut Commands) {
    // Use the same pattern to draw the ball
    // It needs the Collides and Ball marker components
}

#[derive(Default)]
struct Score {
    player_1: usize,
    player_2: usize,
}

// This system will need more arguments to handle rendering appropriately
fn display_score(score: Res&lt;Score&gt;) {
    // Display the score, updating each frame
}

// We can create a custom event type to pass information about scoring between systems
struct ScoreEvent {
    scoring_player: u8,
}

fn check_for_points(
    query: Query&lt;&amp;Transform, With&lt;Ball&gt;&gt;,
    arena_dimensions: Res&lt;'_, &amp;'static ArenaDimensions&gt;,
    score_events: ResMut&lt;ScoreEvent&gt;,
) {
    // Check if the ball is low enough to touch the ground

    // Then use the arena_dimensions to determine whose side of the court it's on

    // Emit an event containing the identity of the player who scored
}

fn update_score(
    mut score: ResMut&lt;Score&gt;,
    mut score_event_reader: Local&lt;EventReader&lt;ScoreEvent&gt;&gt;,
    score_events: Res&lt;Events&lt;KeyboardInput&gt;&gt;,
) {
    // Parse our ScoreEvents, and update our Score resource accordingly
}

// Multiple systems can safely read from the same Event stream
// They are non-consuming, and always persist for one or two ticks
fn reset_ball(
    mut query: Query&lt;&amp;mut Transform, With&lt;Ball&gt;&gt;,
    mut score_event_reader: Local&lt;EventReader&lt;ScoreEvent&gt;&gt;,
    score_events: Res&lt;Events&lt;KeyboardInput&gt;&gt;,
) {
    // If a ScoreEvent has been added to our reader since this system last ran

    // Then, reset the ball's position
}
</code></pre></pre>
<h2><a class="header" href="#queries" id="queries">Queries</a></h2>
<p>In order to access our components in our systems, we need to supply our system with query arguments.
Queries have <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Query.html">two type arguments</a> a <code>WorldQuery</code> and an optional <code>QueryFilter</code>.</p>
<p>You can create a <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.WorldQuery.html"><code>WorldQuery</code></a> by providing either a single component or a tuple of components as the first type argument in a <code>Query</code> parameter of your system.
That <code>Query</code> will return the specified components for all entities that have <em>all</em> of those components.</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use std::fmt;

fn main() {
    App::build()
        .add_plugins(MinimalPlugins)
        .add_startup_system(spawn_readers.system())
        // This system shows the reader's initial education
        .add_startup_system(report_education.system())
        .add_system(educate.system())
        // This system shows it after they've been taught!
        .add_system(report_education.system())
        .run()
}

const N_READERS: usize = 10;
struct Name {
    name: String,
}

impl fmt::Display for Name {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.name)
    }
}

struct Educated {
    educated: bool,
}

impl fmt::Display for Educated {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let out = if self.educated{&quot;educated&quot;} else {&quot;uneducated&quot;};
        write!(f, &quot;{}&quot;, out)
    }
}

fn spawn_readers(commands: &amp;mut Commands) {
    for i in 1..N_READERS {
        let i_string = i.to_string();
        let name = [&quot;Anonymous Reader&quot;, &amp;*i_string].join(&quot; &quot;);
        // Because our variable name is the same as our field name,
        // we can elide `Name{name: name}`
        // into `Name{name}`
        commands.spawn((Name { name }, Educated { educated: false }));
    }
}

// We need to access everything mutably 
// so we can change it
fn educate(mut query: Query&lt;&amp;mut Educated&gt;) {
    // Queries are typically iterated over
    // We're changing the values here, so need `iter_mut`
    // and `mut educated`
    for mut educated in query.iter_mut() {
        // In practice, you'll want to speed this up by impl Deref and DerefMut
        // for your structs with one field
        educated.educated = true;
    }
}

// Entity can be included in your queries, because it has the WorldQuery trait
fn report_education(query: Query&lt;(Entity, &amp;Name, &amp;Educated)&gt;) {
    // Use tuple unpacking to access the components in your queries
    for (entity, name, educated) in query.iter() {
        println!(
            &quot;{}, with an entity identifier of {:?}, is {}.&quot;,
            name, entity, educated
        );
    }
}
</code></pre></pre>
<h3><a class="header" href="#accessing-heterogenous-data-with-queries-for-optionc-components" id="accessing-heterogenous-data-with-queries-for-optionc-components">Accessing Heterogenous Data with Queries for Option<C> Components</a></h3>
<p>With the help of <a href="https://doc.rust-lang.org/rust-by-example/std/option.html"><code>Option&lt;C&gt;</code></a>, we can construct more sophisticated queries by understanding the algorithm used to determine which entities are accessed:</p>
<ol>
<li>Begin with a list of all entities.</li>
<li>For each type in our <code>WorldQuery</code> that is not an <code>Option</code>, remove all entities that lack that component.</li>
<li>For each of the entities in the list, return the component data for each type in our <code>WorldQuery</code>. If it is an <code>Option</code>, return the component data for the wrapped type instead, wrapped in an <code>Option</code> in case it doesn't exist.</li>
</ol>
<p>Under the hood, this is done using <a href="internals/archetypes.html">archetypes</a> rather than entities for performance.</p>
<p>Readers who have experience with relational databases will notice that this results in:</p>
<ol>
<li>An inner join between all ordinary component types in our <code>WorldQuery</code>: only providing the data if every field exists.</li>
<li>An outer join with all <code>Option</code> component types in our <code>WorldQuery</code>: providing the data even if the field doesn't exist.</li>
</ol>
<p>There are a few useful patterns with this functionality:</p>
<ul>
<li>Reducing code duplication by handling simple edge cases within the system itself.</li>
<li>Overriding a default behavior when specialized data exists.</li>
<li>Determining which variant we received when using <code>Or</code> query filters.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<h3><a class="header" href="#query-sets" id="query-sets">Query Sets</a></h3>
<p>Your systems can have multiple <code>Query</code> parameters, but you cannot access the same data in them due to restrictions imposed by Rust's borrow checker.
If you need to, you can bypass this limitation using the <code>QuerySet</code> type:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<h2><a class="header" href="#query-filters" id="query-filters">Query Filters</a></h2>
<p>Once we have the initial list of entities from <code>WorldQuery</code>, we can further restrict it using the second optional type parameter of <code>Query</code>: <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.QueryFilter.html"><code>QueryFilter</code></a>.</p>
<p>Bevy comes with several filters:</p>
<ul>
<li><code>With&lt;T&gt;</code>: Only include entities that have the component <code>T</code>. This can be particularly handy when working with marker components, as it lets you extract only the entities with that marker component without grabbing the useless unit struct itself.</li>
<li><code>Without&lt;T&gt;</code>: Exclude all entities with the component <code>T</code>.</li>
<li><code>Added&lt;T&gt;</code>: Only include entities whose component <code>T</code> could have been added during this tick. This picks up entities that are spawned as well.</li>
<li><code>Mutated&lt;T&gt;</code>: Only include entities whose component <code>T</code> <em>could have</em> been modified during this tick. Note that you could change a different component on that entity without causing it to be marked as mutated. 
<ul>
<li><a href="https://github.com/bevyengine/bevy/blob/457a8bd17d5f5d30a5a2fb6eabce7fc0b95bfc94/crates/bevy_ecs/src/core/borrow.rs#L168">Deep within the engine</a>, this is flagged when a mutable reference to our component is dereferenced. 
If you carefully avoid doing so unnecessarily, you can prevent your component from being marked as mutated unless you actually change its value.</li>
</ul>
</li>
<li><code>Changed&lt;T&gt;</code>:Only include entities that meet the criteria for either <code>Added&lt;T&gt;</code> or <code>Mutated&lt;T&gt;</code> during this tick. This is usually what you want, rather than <code>Added</code> or <code>Mutated</code>.</li>
<li><code>Removed&lt;T&gt;</code>: Only include entities that have also had the specified component removed during this tick. This is commonly used with a <code>Query&lt;(Entity, U), Removed&lt;T&gt;&gt;</code>, to extract the <code>Entity</code> identifier and use it to update a second component <code>U</code> that stored a relation to another entity.</li>
<li><code>Or&lt;T&gt;:</code> Combine query filters via a logical OR, rather than the usual AND logic.</li>
</ul>
<p>Be careful when using <code>Added</code>, <code>Mutated</code>, <code>Changed</code> or <code>Removed</code>: <a href="https://github.com/bevyengine/bevy/issues/68#issuecomment-751311732">right now</a>, they only detect changes made by systems that ran before them in the same tick.</p>
<p>Like with <code>WorldQuery</code>, you can combine these types to create more complex filters. Here's an example demonstrating their capabilities:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<h3><a class="header" href="#working-with-query-objects" id="working-with-query-objects">Working with Query Objects</a></h3>
<p>Once you have your query, you'll most commonly want to interact with it through iterables.
These implement the <a href="https://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html"><code>Iterator</code></a> trait via <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.QueryIter.html">'QueryIter'</a>, so you have access to all sorts of convenient functional programming tools:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<h3><a class="header" href="#accessing-specific-entities" id="accessing-specific-entities">Accessing Specific Entities</a></h3>
<p>One particularly useful but non-obvious pattern is to work with relationships between entities by storing an <code>Entity</code> on one component, then. Here's an example of how it might work. Be mindful though: the <code>Entity</code> stored in your component can easily end up stale as entities are removed, and you need to be careful that this doesn't cause panics or logic errors.
You can fetch components from particular entities using the <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Query.html#method.get"><code>query.get</code></a> family of methods:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<p>The <code>Parent</code> and <code>Child</code> components in Bevy, used for defining organizational hierarchies to control positioning, uses this pattern.</p>
<h2><a class="header" href="#generic-systems" id="generic-systems">Generic Systems</a></h2>
<p>When working with multiple similar objects, we can use Rust's <a href="https://doc.rust-lang.org/book/ch10-00-generics.html">generics</a> to allow us to comfortably specialize behavior of our systems.
This pattern allows us to keep our components small (allowing each variant system to run in parallel) and specialize behavior when it matters, without duplicating shared code.</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<h2><a class="header" href="#thread-local-systems" id="thread-local-systems">Thread-Local Systems</a></h2>
<p>When you need to work with <a href="resources.html">thread-local resources</a> or need complete access to all resources and components (like when saving or loading a game), you can use a <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/prelude/trait.System.html#tymethod.run_thread_local">thread-local</a> system.</p>
<p>While thread-local systems block all other systems, they give you full mutable access to every component and resource:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run()
}
</code></pre></pre>
<p>Thread-local systems are less performant and harder to reason about than ordinary systems: don't use them unless you have to. 
If you just want to ensure that your systems run one-by-one in a fixed order, use <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.SystemStage.html#method.serial"><code>SystemStage::serial()</code></a> instead.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../ecs/entities-components.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../ecs/resources.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../ecs/entities-components.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../ecs/resources.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
