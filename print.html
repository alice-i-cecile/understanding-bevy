<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Understanding Bevy</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ecs/_index.html"><strong aria-hidden="true">2.</strong> Entities, Components and Systems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecs/entities-components.html"><strong aria-hidden="true">2.1.</strong> Entities and Components</a></li><li class="chapter-item expanded "><a href="ecs/systems.html"><strong aria-hidden="true">2.2.</strong> Systems amd Queries</a></li><li class="chapter-item expanded "><a href="ecs/resources.html"><strong aria-hidden="true">2.3.</strong> Resources</a></li><li class="chapter-item expanded "><a href="ecs/timing/_index.html"><strong aria-hidden="true">2.4.</strong> Control Flow and Timing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecs/timing/scheduling-stages.html"><strong aria-hidden="true">2.4.1.</strong> System Scheduling and Stages</a></li><li class="chapter-item expanded "><a href="ecs/communication/conditional-systems.html"><strong aria-hidden="true">2.4.2.</strong> Run Criteria and States</a></li><li class="chapter-item expanded "><a href="ecs/timing/timers.html"><strong aria-hidden="true">2.4.3.</strong> Timers and Time Steps</a></li></ol></li><li class="chapter-item expanded "><a href="ecs/communication/_index.html"><strong aria-hidden="true">2.5.</strong> Tools for Intersystem Communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecs/communication/commands.html"><strong aria-hidden="true">2.5.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="ecs/communication/events.html"><strong aria-hidden="true">2.5.2.</strong> Events</a></li><li class="chapter-item expanded "><a href="ecs/communication/chaining.html"><strong aria-hidden="true">2.5.3.</strong> Chaining Systems</a></li></ol></li><li class="chapter-item expanded "><a href="ecs/internals/_index.html"><strong aria-hidden="true">2.6.</strong> ECS Internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ecs/internals/app-builder.html"><strong aria-hidden="true">2.6.1.</strong> App Builder</a></li><li class="chapter-item expanded "><a href="ecs/internals/world.html"><strong aria-hidden="true">2.6.2.</strong> World</a></li><li class="chapter-item expanded "><a href="ecs/internals/default-plugins.html"><strong aria-hidden="true">2.6.3.</strong> Default Plugins</a></li><li class="chapter-item expanded "><a href="ecs/internals/archetypes.html"><strong aria-hidden="true">2.6.4.</strong> Archetypes</a></li><li class="chapter-item expanded "><a href="ecs/internals/reflection.html"><strong aria-hidden="true">2.6.5.</strong> Reflection</a></li></ol></li><li class="chapter-item expanded "><a href="ecs/think-ecs.html"><strong aria-hidden="true">2.7.</strong> Think ECS: Idiomatic Problem Solving in Bevy</a></li></ol></li><li class="chapter-item expanded "><a href="organization/_index.html"><strong aria-hidden="true">3.</strong> Organizing Your Bevy Codebase</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="organization/project-structure.html"><strong aria-hidden="true">3.1.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="organization/plugins.html"><strong aria-hidden="true">3.2.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="organization/scenes.html"><strong aria-hidden="true">3.3.</strong> Scenes</a></li></ol></li><li class="chapter-item expanded "><a href="serialization/_index.html"><strong aria-hidden="true">4.</strong> Serialization and Networking</a></li><li class="chapter-item expanded "><a href="graphics/_index.html"><strong aria-hidden="true">5.</strong> Graphics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphics/assets-sprites.html"><strong aria-hidden="true">5.1.</strong> Assets and Sprites</a></li><li class="chapter-item expanded "><a href="graphics/transforms.html"><strong aria-hidden="true">5.2.</strong> Transforms</a></li><li class="chapter-item expanded "><a href="graphics/cameras.html"><strong aria-hidden="true">5.3.</strong> Cameras</a></li><li class="chapter-item expanded "><a href="graphics/children.html"><strong aria-hidden="true">5.4.</strong> Hierarchy: Parents and Children</a></li><li class="chapter-item expanded "><a href="graphics/animation.html"><strong aria-hidden="true">5.5.</strong> Animation</a></li><li class="chapter-item expanded "><a href="graphics/meshes.html"><strong aria-hidden="true">5.6.</strong> Meshes</a></li><li class="chapter-item expanded "><a href="graphics/shaders.html"><strong aria-hidden="true">5.7.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="graphics/vector_graphics.html"><strong aria-hidden="true">5.8.</strong> Vector Graphics</a></li></ol></li><li class="chapter-item expanded "><a href="ui/_index.html"><strong aria-hidden="true">6.</strong> User Interfaces</a></li><li class="chapter-item expanded "><a href="audio/_index.html"><strong aria-hidden="true">7.</strong> Audio</a></li><li class="chapter-item expanded "><a href="input/_index.html"><strong aria-hidden="true">8.</strong> Input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input/keyboard.html"><strong aria-hidden="true">8.1.</strong> Keyboard</a></li><li class="chapter-item expanded "><a href="input/mouse.html"><strong aria-hidden="true">8.2.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="input/controller.html"><strong aria-hidden="true">8.3.</strong> Controller</a></li><li class="chapter-item expanded "><a href="input/touch.html"><strong aria-hidden="true">8.4.</strong> Touch</a></li></ol></li><li class="chapter-item expanded "><a href="physics/_index.html"><strong aria-hidden="true">9.</strong> Physics</a></li><li class="chapter-item expanded "><a href="development/_index.html"><strong aria-hidden="true">10.</strong> Productive Development in Bevy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/compiling.html"><strong aria-hidden="true">10.1.</strong> Compiling your Game</a></li><li class="chapter-item expanded "><a href="development/testing.html"><strong aria-hidden="true">10.2.</strong> Idiomatic Automated Testing</a></li><li class="chapter-item expanded "><a href="development/diagnostics.html"><strong aria-hidden="true">10.3.</strong> Diagnostics and Debugging</a></li><li class="chapter-item expanded "><a href="development/cross-platform.html"><strong aria-hidden="true">10.4.</strong> Cross-Platform Support</a></li><li class="chapter-item expanded "><a href="development/releasing.html"><strong aria-hidden="true">10.5.</strong> Releasing your Game</a></li><li class="chapter-item expanded "><a href="development/common-issues.html"><strong aria-hidden="true">10.6.</strong> Common Issues and Finding Help</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Understanding Bevy</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><a href="https://bevyengine.org/">Bevy</a> is a fantastic, free, open source, ECS-style game engine written in Rust. This book is <a href="https://github.com/alice-i-cecile">my</a> attempt to collect, summarize and contextualize the engine and its ecosystem. This book was written for Bevy 0.4, and assumes familiarity with core Rust concepts (like lifetimes, traits, objects and iterators), but no previous experience with either Bevy or game programming as a whole. If you have any suggestions, questions, or spot an error, please feel free to open an issue on this site's <a href="https://github.com/alice-i-cecile/understanding-bevy">Github</a>.</p>
<p>This book is deliberately opinionated: rather than simply reiterating the API that Bevy offers you, it attempts to provide context on the options available and when you should reach for a particular tool. 
Ideally, this book will teach how you should write elegant, performant and idiomatic game code in Bevy + Rust and Bevy and steer you away from obvious pitfalls that may seem tempting at first glance.</p>
<p>Right now, many of these sections of this book are incomplete, but the sections that are complete should be quite helpful and usable. This book, and the advice in it, is likely to remain very unstable until Bevy hits 1.0 at some point in the distant future.</p>
<h2><a class="header" href="#why-you-should-use-bevy" id="why-you-should-use-bevy">Why You Should Use Bevy</a></h2>
<ul>
<li>
<p>blazing fast ECS system with exceptional ergonomics: minimal boilerplate, repeated use of a few simple and powerful patterns</p>
</li>
<li>
<p>fully configurable: strip out the bits you don't need, replace them, or hack the core code yourself</p>
</li>
<li>
<p>written in Rust, offering fantastic speed, modern ergonomics and superior memory safety</p>
</li>
<li>
<p>actively developed and carefully curated, with a commitment to code quality</p>
</li>
<li>
<p>helpful, friendly, and expert community</p>
</li>
</ul>
<h2><a class="header" href="#why-you-shouldnt-use-bevy" id="why-you-shouldnt-use-bevy">Why You Shouldn't Use Bevy</a></h2>
<ul>
<li>
<p>immature: many core functionalities (e.g. asset pipelines, scripting pipelines, advanced scenes, networking) are still incomplete</p>
</li>
<li>
<p>no visual editor, limiting its accessibility</p>
</li>
<li>
<p>unstable API, likely to break repeatedly</p>
</li>
<li>
<p>poorly documented (hence this book!)</p>
</li>
</ul>
<h2><a class="header" href="#further-reading" id="further-reading">Further Reading</a></h2>
<p>As you read along, there are a few key resources you should be aware of:</p>
<ul>
<li>
<p>The <a href="https://bevyengine.org/learn/book/introduction/">Bevy Book</a>: a great example-driven introduction to the library</p>
</li>
<li>
<p>The <a href="https://docs.rs/bevy/">Bevy Rust API docs</a>: for looking up the details of a particular bit of code</p>
</li>
<li>
<p>The <a href="https://github.com/bevyengine/bevy">official Github</a>: the source code is quite legible, and the issues, pull requests and discussions are where the serious engine development takes place</p>
</li>
<li>
<p>The official <a href="https://github.com/bevyengine/bevy/tree/master/examples">Bevy examples</a>: a fantastic collection of idiomatic snippets that demonstrate core functionality</p>
</li>
<li>
<p><a href="https://github.com/bevyengine/awesome-bevy">Awesome Bevy</a>: a collection of examples, tutorials and resources for learning and using Bevy</p>
</li>
<li>
<p>The <a href="https://discord.com/invite/gMUk5Ph">Bevy Discord community</a>: a friendly, active group for troubleshooting help and casual engine development discussion</p>
</li>
</ul>
<p>Now, let me show you the <code>World</code> of Bevy.</p>
<h1><a class="header" href="#entities-components-and-systems" id="entities-components-and-systems">Entities, Components and Systems</a></h1>
<p>Bevy supported version:</p>
<pre><code>bevy = &quot;0.4&quot;
</code></pre>
<p>At its heart, Bevy operates using an <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity-Component-System</a> model. Rather than operating in a traditional object-oriented fashion, where your game is composed of individual objects with properties and methods, ECS games work in a fashion that is much closer to a relational database: grouping similar data together in a memory-dense fashion, with the <code>Entity</code> serving as a primary key to identify the data, then processing the game data in a batch-wise fashion.</p>
<p>Games in Bevy are largely composed of five core building blocks, that come up again and again:</p>
<ul>
<li><strong>Entity:</strong> <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Entity.html">Entities</a> are simple, unique identifiers, and nothing more. Given a component, the entity signifies which in-game object the stored data belongs to, thus &quot;grouping&quot; different components together.</li>
<li><strong>Components:</strong> <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.Component.html">Components</a> refer to data that is associated with an entity. You can use any thread-safe Rust type as a component, and they are stored in a performant fashion using <a href="ecs/internals/archetypes.html">archetypes</a>.</li>
<li><strong>Systems:</strong> <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.System.html">Systems</a> are largely-ordinary Rust functions that handle the game logic. They access components through <a href="ecs/../../book/ecs/queries.html">queries</a> and can directly read and write resources (including <a href="ecs/communication/commands.html">Commands</a> and <a href="ecs/communication/events.html">Events</a>). When added to your game, they automatically fetch data of the appropriate type, and are run in parallel by the <a href="ecs/timing/scheduling.html">scheduler</a> based on the resources and components that they read and write.</li>
<li><strong>Resources:</strong> <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.Resource.html">Resources</a> are well-behaved global singletons that are used to store cross-system game state that isn't associated with a particular entity. Like with components, you can use any thread-safe Rust type as a Resource. </li>
<li><strong>Assets:</strong> <a href="https://docs.rs/bevy/0.4.0/bevy/asset/struct.Assets.html">Assets</a> are blocks of data that are used to create content for your game. Game models, raster graphics for your UI, sound effects and so on are all assets. Unlike resources, these are saved on the disc, rather than created by the engine.</li>
</ul>
<h2><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h2>
<p>To get started, <a href="https://www.rust-lang.org/tools/install">Install Rust</a>, then set up a new Bevy project (&quot;Add Bevy as a Dependency&quot;) as described in the <a href="https://bevyengine.org/learn/book/getting-started/">official book</a>.</p>
<p>The boilerplate needed to make your own app is simple:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().run();
}
</code></pre></pre>
<p>If you're looking for some useful functionality out of the box (windowing, graphics, input, a scheduler that automatically loops etc.), you'll want to add <a href="https://docs.rs/bevy/0.4.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> as well.</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(DefaultPlugins).run();
}
</code></pre></pre>
<p>If all you need is a simple scheduler, you can use the minimal <a href="https://docs.rs/bevy/0.4.0/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> instead. This is a nice pattern for writing tests or examples, but could also be useful for running in headless mode or if you wanted to use Bevy's scheduler and ECS as part of a program that doesn't a GUI frontend.</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

fn main() {
    App::build().add_plugins(MinimalPlugins).run();
}
</code></pre></pre>
<p>By chaining methods together on the <a href="ecs/internals/app-builder.html"><code>AppBuilder</code></a> that we created with <code>App::build</code>, we can carefully build up our game's functionality in a modular fashion with the <a href="https://refactoring.guru/design-patterns/builder">Builder pattern</a>.</p>
<p>To give you a taste of the syntax for Bevy's ECS, here's a not-quite-minimal Hello World example: </p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use std::collections::HashMap;
use std::fmt;

// Denizen is a &quot;marker component&quot; here, to allow us to filter for denizens in our queries
// In general, marker components do not store data, and are just used for queries
// Marker components are talked about in more detail in section 2.2: Components
#[derive(Debug)]
struct Denizen;

// We use the owned form String, rather than &amp;str in this struct
// Because resources and components must be thread-safe with a 'static lifetime
#[derive(Hash, PartialEq, Eq, Clone, Debug)]
struct Name(String);

// A custom impl of Display to ensure we can print these names nicely
impl fmt::Display for Name {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.0)
    }
}

#[derive(Clone, Debug)]
enum World {
    Venus,
    Earth,
    Mars,
}

// Creating a unique timer type for each system that needs one allows us to be sure we're grabbing the right one
struct HelloTimer(Timer);

fn main() {
    App::build()
        // We add the default plugins so our game will loop
        // This also adds the Time resource that we use in `say_hello`
        .add_plugins(DefaultPlugins)
        // We're creating a HashMap to record which planet entities a name are on
        .add_resource(HashMap::&lt;Name, World&gt;::new())
        // Startup systems only run once, before normal systems take place
        .add_startup_system(place_denizens.system())
        // When systems cannot be run in parallel, priority is based on insertion order
        .add_startup_system(spawn_denizens.system())
        // The `say_hello` system will be run every frame, but only prints when the timer is complete
        // (See `say_hello` logic)
        .add_resource(HelloTimer(Timer::from_seconds(2.0, true)))
        .add_system(say_hello.system())
        .run();
}

// Because we're modifying the `directory` argument, we need to get the mutable version of it with `ResMut`
// Bevy's ECS finds a Resource with the matching type; we want to be sure we have exactly one resource of each type that we need
fn place_denizens(mut directory: ResMut&lt;HashMap&lt;Name, World&gt;&gt;) {
    // .into() converts our string literal from &amp;str to the required String
    directory.insert(Name(&quot;Alice&quot;.into()), World::Venus);
    directory.insert(Name(&quot;Bevy&quot;.into()), World::Earth);
    directory.insert(Name(&quot;Cart&quot;.into()), World::Mars);
}

// The special `Commands` resource queues up actions that should be performed to modify the World
// We only need to read from the directory resource, so we can call it with `Res` instead of `ResMut`
fn spawn_denizens(commands: &amp;mut Commands, directory: Res&lt;HashMap&lt;Name, World&gt;&gt;) {
    // We need to use .clone and .into_iter rather than .iter here
    // to satisfy the lifetime requirements of .spawn()
    for (name, world) in directory.clone().into_iter() {
        if name == Name(&quot;Bevy&quot;.into()) {
            // .spawn creates new entities with the specified components
            // each tuple entry is a different component
            commands.spawn((name, world));
        } else {
            // Only Alice and Cart are Denizens, so Bevy will be excluded from our query filter in `say_hello`
            commands.spawn((name, world, Denizen));
        }
    }
}

// Queries extract each entity that have all of the components specified in their first type argument
// They only return the components specified in the query, not any other components that may be associated with the entities
// The second type argument is a query filter, which restricts which entities are actually provided
fn say_hello(
    query: Query&lt;(&amp;Name, &amp;World), With&lt;Denizen&gt;&gt;,
    mut timer: ResMut&lt;HelloTimer&gt;,
    time: Res&lt;Time&gt;,
) {
    // Only run this system when the timer has elapsed
    if timer.0.tick(time.delta_seconds()).just_finished() {
        // Iterating over and then unpacking the query gives us access to the components for each of its entities
        for (name, world) in query.iter() {
            // Because we're querying for &amp;Query and &amp;World, we need to dereference them before we work with them
            println!(&quot;Hello {:?}, my name is {}!&quot;, *world, *name);
        }
    }
}
</code></pre></pre>
<p>If you want to dive right into more realistic code-bases, check out the extensive <a href="https://github.com/bevyengine/bevy/tree/master/examples">examples</a> section of the official repo, or the examples and tutorials found at <a href="https://github.com/bevyengine/awesome-bevy#games">awesome-bevy</a>.</p>
<h1><a class="header" href="#entities-and-components" id="entities-and-components">Entities and Components</a></h1>
<p>The ECS architecture, at its heart, is about efficiently laying out data, and then accessing it in principled ways.
Drawing on the metaphors of databases, we can think of each <strong>component</strong> as representing a unique column of data, with a homogenous type, and each row determines which entity that component belongs to.</p>
<p>Every entity in Bevy has a special component called <code>Entity</code>, which serves as our primary key into the database, allowing us to fetch the appropriate component efficiently. In <a href="ecs/internals/archetypes.html">archetypal</a> ECS, like Bevy, we can extend this metaphor further. An archetype is a collection of entities with a specific set of components: creating an efficient sub-table where every cell, regardless of its entity or component, has a valid entry.</p>
<p>When we want to read or modify the data stored in our components, we can use a <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Query.html"><code>Query</code></a>: allowing us to extract the columns we care about. We can further filter within this <code>Query</code> by using a <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.QueryFilter.html"><code>QueryFilter</code></a>, allowing us to limit ourselves to only entities that have or lack a certain component, or have recently changed.</p>
<h2><a class="header" href="#designing-components" id="designing-components">Designing Components</a></h2>
<p>In Bevy, you can make nearly anything a component: merely give it a unique type (see <a href="ecs/resources.html#ensuring-unique-resource-types"><em>Ensuring Unique Resource Types</em></a> for tips) add it your entities, and then query away. 
The only caveat is that it must fulfill the <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.Component.html"><code>Component</code></a> trait: it must be <code>Send + Sync + 'static</code>, allowing us to safely pass components between threads.</p>
<p>As your codebase grows, you're going to want to <code>impl Default</code> (or create a <code>new</code> method) for most of your component types or component bundles. 
This helps ensure consistent behavior (rather than having to track down 17 different constants) and can make spawning new entities less onerous.</p>
<p>Because Bevy's <a href="ecs/timing/scheduling.html">scheduler</a> allows us to automatically parallelize systems that don't have conflicting read/write demands on our components or systems, it's good practice to make your components small. 
You should continue to break down your components until you're reasonably sure that hypothetical future systems will never want to consume one of its fields without the context of at least one other piece. 
Even if they're commonly used together, you should consider using a component bundle of small components, rather than one large component.</p>
<p>This practice also makes it much easier to extend your systems to support new, possibly unplanned behavior. 
From a design perspective, components in ECS fill a very similar role to Rust's traits. 
Rather than needing to think about precisely which [types / archetypes] our [functions / systems] are running on, [traits / components] guarantee the presence of certain data, and the desirability of certain behavior.</p>
<p>This allows us to skip verifying that the entity that we're operating on has certain properties; instead constructing more expressive type signatures for your queries (corresponding to more exact trait bounds). 
This is harder to accidentally break, easier to read, and should permit more of your systems to run in parallel as you only request the exact data you'll be operating on.</p>
<h3><a class="header" href="#marker-components" id="marker-components">Marker Components</a></h3>
<p>When translating a game design to an ECS paradigm, you'll often want to be able to easily toggle behavior for different entities based on one of their properties.
The idiomatic way to do so is to create a <strong>marker component</strong>: a data-less <a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">unit struct</a> that can be used to filter the entities returned by your queries using <code>With</code> or <code>Without</code> (see below). Here's some guidance on when you might want to use them:</p>
<ul>
<li>Marker components are great for controlling whether a behavior (or set of behaviors) occurs at all. for things like enabling collisions or handling buffs.</li>
<li>If you always want to perform a behavior, but with some variants, control it using data stored in your component (as a field or as an enum), rather than proliferating marker components.</li>
<li>Adding and removing components has a substantial performance cost in archetype-based ECS like Bevy. If your game is performance-limited, marker components may be the wrong tool for handling things like short-lived buffs.</li>
</ul>
<h3><a class="header" href="#option-components" id="option-components">Option Components</a></h3>
<p>Sometimes, you don't know the value of a component at the time of its creation (or it may sometimes cease to exist during the course of gameplay). 
This might commonly be observed for components that relate one entity to another by storing an <code>Entity</code> as part of their data: defining a parent-child relationship, designating a target or so on. 
A useful pattern here is to wrap your component type <code>T</code> in an <code>Option&lt;T&gt;</code>, allowing you to safely set its value to <code>None</code>.
This ensuring that it shows up in the appropriate queries, its archetype is stable (helping performance) and you can take advantage of Rust's enum matching tools to ensure that you're always handling the possibility of missing data appropriately.</p>
<h3><a class="header" href="#component-bundles" id="component-bundles">Component Bundles</a></h3>
<p>In certain complex subsystems of our game, we may want large quantities of related data to be created and consumed at the same time.
Bevy offers <strong>component bundles</strong> for this purpose, allowing us to stick to small, modular components while providing some nice sugar to ensure that components aren't carelessly forgotten.</p>
<p>Bevy itself uses this pattern for <a href="ecs/../graphics/assets-sprites.html">Sprites</a>, <a href="ecs/../ui/_index.html">UI</a>, <a href="ecs/../graphics/cameras.html">Cameras</a> and so on. Here's a quick demo of how you might work with bundles (both <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.Bundle.html">static</a> and <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/trait.DynamicBundle.html">dynamic</a>):</p>
<p><code>rust </code></p>
<h2><a class="header" href="#spawning-and-despawning-entities" id="spawning-and-despawning-entities">Spawning and Despawning Entities</a></h2>
<p>In order for your nicely-architected components to do much of anything, you're going to want to create some entities with those components.
Pass in a tuple of components or a component bundle to <code>commands.spawn</code> and you'll get a new entity with those components:</p>
<p><code>rust </code></p>
<p>Despawning entities is easy, so long as you know which entity to grab:</p>
<p><code>rust </code></p>
<p>Because entity creation and deletion are wide-reaching operations that involve altering archetypes, they can only be done via <a href="ecs/communication/commands.html"><code>Commands</code></a> or in a thread-local system by modifying <a href="ecs/">World</a>. 
As a result, they will not take effect until the end of the current <a href="ecs/timing/stages.html">stage</a>.</p>
<p>When you're creating many of the same archetype of entity at once, it's somewhat more efficient to <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Commands.html#method.spawn_batch">spawn them in a batch</a>, allowing Bevy to allocate memory a single time. To do so, you need to create an appropriate iterator:</p>
<p><code>rust</code></p>
<h2><a class="header" href="#modifying-components-after-creation" id="modifying-components-after-creation">Modifying Components After Creation</a></h2>
<p>While changing the archetype of an entity has a performance cost, it can often be the clearest way to handle a change in an entity's behavior.
You can add and remove components to entities with <code>insert</code>, <code>remove</code>, <code>insert_one</code> and <code>remove_one</code> (<a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Commands.html#method.insert">see the methods on <code>Commands</code></a>):</p>
<p><code>rust</code></p>
<p>Like entity creation and deletion, modifying components can only be done via <code>Commands</code> or in a thread-local system and will not take effect until the end of the current stage.</p>
<h2><a class="header" href="#fetching-components-from-a-specific-entity" id="fetching-components-from-a-specific-entity">Fetching Components from a Specific Entity</a></h2>
<p>One particularly useful but non-obvious pattern is to work with relationships between entities by storing an <code>Entity</code> on one component, then. Here's an example of how it might work. Be mindful though: the <code>Entity</code> stored in your component can easily end up stale as entities are removed, and you need to be careful that this doesn't cause panics or logic errors. </p>
<p><code>rust </code></p>
<h1><a class="header" href="#systems-and-queries" id="systems-and-queries">Systems and Queries</a></h1>
<p>In Bevy, <strong>systems</strong> are the beating heart of your game: containing all of the necessary logic to actually <em>make stuff happen</em>.</p>
<h2><a class="header" href="#what-makes-a-system" id="what-makes-a-system">What Makes a System</a></h2>
<h2><a class="header" href="#queries" id="queries">Queries</a></h2>
<h2><a class="header" href="#query-filters" id="query-filters">Query Filters</a></h2>
<h2><a class="header" href="#concurrency-and-parallelism" id="concurrency-and-parallelism">Concurrency and Parallelism</a></h2>
<h3><a class="header" href="#thread-local-systems" id="thread-local-systems">Thread-Local Systems</a></h3>
<h2><a class="header" href="#no-but-really-how-does-it-work" id="no-but-really-how-does-it-work">No But Really, How Does it Work?</a></h2>
<h1><a class="header" href="#resources" id="resources">Resources</a></h1>
<p>When the data you're looking to store isn't associated with any particular entity, you can stick into a convenient <a href="ecs/(https://docs.rs/bevy/0.4.0/bevy/ecs/trait.Resource.html)"><code>Resource</code></a>.
<strong>Resources</strong> are global singletons, accessed by their type, which can be used to store global state.
You might want to use resources for storing and configuring settings, handling a complex data structure like a player's inventory that doesn't fit naturally into the ECS model, or tracking game state like the player's score.</p>
<p>You can use virtually any Rust type as a resource, but if possible, you're going to want your resources to be thread-safe: <code>'static</code> lifetime and <code>Send + Sync</code>.</p>
<h2><a class="header" href="#creating-resources" id="creating-resources">Creating Resources</a></h2>
<p>Assuming that we're working with a thread-safe resource that isn't system local, there are two different ways we can add resources to our app.</p>
<p>When you're working with your <a href="ecs/../internals/app-builder.html"><code>AppBuilder</code></a> (including through a <a href="ecs/../../organization/plugins.html">plugin</a>), there are two ways to add resources:</p>
<ol>
<li>
<p><a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.AppBuilder.html#method.init_resource"><code>init_resource</code></a>, which adds a resource of the type specified in its type parameter, with a starting value given by its <code>Default</code> trait.</p>
</li>
<li>
<p><a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.AppBuilder.html#method.add_resource"><code>.add_resource</code></a>, which sets a custom starting value for that type.</p>
</li>
</ol>
<p>Use <code>.init_resource</code> when you're planning to set it in a later system (perhaps because you need more complex logic), and use <code>.add_resource</code> when you have a good starting value.</p>
<p>If you need to add or overwrite Resources at run-time, consider using <a href="ecs/commands.html">commands</a> with the <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Commands.html#method.insert_resource">.insert_resource</a> method, which works the same as <code>.add_resource</code> above. Be mindful though: commands don't take effect until the end of each stage. Most of the time, you shouldn't need to do this: to modify a resource, instead create a system that gets a <code>ResMut</code> to the resource in question, then modify it within that system.</p>
<p>Here's how you might add resources of various types for a mock RTS game:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(warnings)]
use bevy::prelude::*;

struct InfantryStats {
    hp: f32,
    damage: f32,
    speed: f32,
}

// In order to use .init_resource, we need to specify a default starting value
// by implementing the Default trait
impl Default for InfantryStats {
    fn default() -&gt; Self {
        InfantryStats {
            hp: 10.0,
            damage: 2.0,
            speed: 1.0,
        }
    }
}

struct PlayerResources {
    gold: usize,
    wood: usize,
}

struct MaxUnits(i32);

enum PlayerColor {
    Red,
    Blue,
    Pink,
}

fn main() {
    App::build()
        .init_resource::&lt;InfantryStats&gt;()
        // Structs and enums can all be used as resources
        .add_resource(PlayerResources {
            gold: 1000,
            wood: 500,
        })
        .add_resource(MaxUnits(100))
        .add_resource(PlayerColor::Pink)
        .run();
}
</code></pre></pre>
<h3><a class="header" href="#thread-local-resources" id="thread-local-resources">Thread-local Resources</a></h3>
<p>If you need a resource that is not thread-safe, you first need to create it with: <a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.AppBuilder.html#method.add_thread_local_resource"><code>.add_thread_local_resource</code></a> or <a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.AppBuilder.html#method.init_thread_local_resource"><code>.init_thread_local_resource</code></a>, whose behavior corresponds to the <code>add_resource</code> and <code>init_resource</code> methods described above. </p>
<p>You might need to use resources that aren't thread-safe when:</p>
<ul>
<li>interfacing with a scripting language like Lua that isn't thread-safe</li>
<li>manipulating reference-counted objects</li>
<li>handling audio-processing, network-queues or other complex data structures that are hard to make thread-safe</li>
</ul>
<p>Be aware: thread-local resources created in this way are a completely distinct concept from those created with the <code>.insert_local_resource</code> method, which use the <code>Local</code> resource smart pointer, which creates a unique instantiation of the resource in the system it is referred to.</p>
<p>Once you have your thread-local resource, you need to use &quot;thread-local systems&quot; (see the corresponding <a href="ecs/../systems.html">section</a> in this book for more information) to manipulate it, which gives you a complete global lock on the entire <a href="https://docs.rs/bevy/0.4.0/bevy/app/struct.App.html">app</a>, with <code>World</code> and all of its <code>Resources</code>.</p>
<p>You can see how you might use thread-local resources in <a href="ecs/../systems.html">thread-local systems</a>.</p>
<h3><a class="header" href="#system-local-resources" id="system-local-resources">System-Local Resources</a></h3>
<p>System-local resources are scoped, mutable resources that are only available in the system that created them. Their state persists between time steps, but not between distinct systems created using the same function, as they work off of the <code>SystemId</code> created at their time of registration.</p>
<p>In typical use, system-local resources are created implicitly, through the use of a <code>Local</code> resource smart-pointer type on one of the function arguments in your system. If you had some reason to manually create or overwrite them, you could instead use <a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Commands.html#method.insert_local_resource"><code>.insert_local_resource</code></a>.</p>
<p>Local resources are a fairly niche tool: use them if you want to track state that will only ever be relevant to a single system that you need to persist across frames. The <a href="https://github.com/bevyengine/bevy/blob/master/examples/ecs/event.rs">official example</a> for <a href="ecs/events.html">Events</a> show how you can use them to create an<code>EventReader</code>, which could persist across frames if not all events were processed in the available time. When you want to have many similar, but distinct systems, you can use system-local resources in combination with generics to get interesting specialization, as shown in this overly-complex <code>Timer</code> example:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;

// By defining a trait, we can ensure that all of our types
// have the required common functionality
trait MyTimer {
	fn access(&amp;mut self) -&gt; &amp;mut Timer;
}

struct SlowTimer(Timer);
struct FastTimer(Timer);

impl Default for FastTimer {
	fn default() -&gt; Self {
		FastTimer(Timer::from_seconds(0.3, true))
	}
}

impl Default for SlowTimer {
	fn default() -&gt; Self {
		SlowTimer(Timer::from_seconds(2.0, true))
	}
}

impl MyTimer for FastTimer {
	fn access(&amp;mut self) -&gt; &amp;mut Timer {
		&amp;mut self.0
	}
}

impl MyTimer for SlowTimer {
	fn access(&amp;mut self) -&gt; &amp;mut Timer {
		&amp;mut self.0
	}
}

fn main() {
	App::build()
		.add_plugins(MinimalPlugins)
		// We can customize two otherwise identical systems by specifying its type
		.add_system(run_timer::&lt;SlowTimer&gt;.system())
		// The timer resource in these two systems are distinct
		.add_system(run_timer::&lt;FastTimer&gt;.system())
		.run();
}

// System-local resources initialize their value with their
// The trait bounds are needed to ensure that any T we might provide will work
fn run_timer&lt;T: Send + Sync + Default + 'static + MyTimer&gt;(time: Res&lt;Time&gt;, mut timer: Local&lt;T&gt;) {
	if timer.access().tick(time.delta_seconds()).just_finished() {
		println!(&quot;The time is {:?}&quot;, *time);
	}
}
</code></pre></pre>
<h2><a class="header" href="#ensuring-unique-resource-types" id="ensuring-unique-resource-types">Ensuring Unique Resource Types</a></h2>
<p>When any of the resource creation methods is called on a type that already exists (with the caveat that system-local resources are effectively scoped), Bevy will overwrite any existing data. As a result, you only ever want to have one resource of a given type in your app at once.</p>
<p>Here are a few patterns you can use to ensure that your resources have a unique type:</p>
<pre><pre class="playground"><code class="language-rust">// In this example, we need many different Resources that use an f32 to store its data
use bevy::prelude::*;
use std::ops::{Deref, DerefMut};

// Creating a type alias for f32
type Score = f32;

// Creating a simple tuple struct using the 'newtype' pattern
// You can do the exact same thing with an ordinary struct if you want the field name
struct FallingThreshold(f32);

// Adding the Deref trait makes these simple structures much more pleasant to work with
// You always want the inner data anyways
impl Deref for FallingThreshold {
    type Target = f32;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl DerefMut for FallingThreshold {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut f32 {
        &amp;mut self.0
    }
}

// Creating a marker struct to combine with our data as a tuple type
// You could easily reuse these as marker components as well
struct Friendly;
struct Hostile;

fn main() {
    App::build()
        // Don't do this: it's really hard to debug and read
        // And also hard to extend with new behavior or traits
        .add_resource(1.0 as f32)
        // This overwrites our previous f32, since type aliasing doesn't create a new type
        .add_resource(2.0 as Score)
        // FallingThreshold is its own type, despite being used like a raw f32
        .add_resource(FallingThreshold(3.0))
        // (Friendly, f32) and (Hostile, f32) are unique types, disambiguating properly
        .add_resource((Friendly, 4.0))
        .add_resource((Hostile, 5.0))
        .run();
}
</code></pre></pre>
<h2><a class="header" href="#using-resources-in-your-systems" id="using-resources-in-your-systems">Using Resources in Your Systems</a></h2>
<p>In order to access resources in a system, wrap the resource type in your function parameters in one of the three smart-pointers.</p>
<ol>
<li>
<p><a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Res.html"><code>Res</code></a>, for when you want read-only access to the underlying data.</p>
</li>
<li>
<p><a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.ResMut.html"><code>ResMut</code></a>, for when you want read and write access to the data.</p>
</li>
<li>
<p><a href="https://docs.rs/bevy/0.4.0/bevy/ecs/struct.Local.html"><code>Local</code></a>, for when you want a system-local resource.</p>
</li>
</ol>
<p>These resource smart pointers all <code>impl Deref</code>, ensuring that rather than needing to call <code>*my_resource</code> each time, you can usually implicitly skip the dereferencing with <code>my_resource</code>. </p>
<p>When you define a system, you can include resources as one of your function parameter. Bevy's scheduler automatically looks for a  previously added resources with a matching type, and passes in a reference of the appropriate type to your system.</p>
<p>We can see the differences between these different resource types in this simple example:</p>
<pre><pre class="playground"><code class="language-rust">use bevy::prelude::*;
use rand::Rng;
use std::collections::HashMap;
use std::fmt;

#[derive(Clone)]
struct Score(u32);

// These derives let us use Player as a key in our HashMap later
#[derive(Hash, PartialEq, Eq, Clone, Copy)]
enum Player {
	Player1,
	Player2,
}

struct Winner(Player);

// The Display trait lets us control how these types are printed
impl core::fmt::Display for Score {
	fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
		write!(f, &quot;{}&quot;, self.0)
	}
}

impl core::fmt::Display for Player {
	fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
		write!(
			f,
			&quot;{}&quot;,
			match &amp;self {
				Player::Player1 =&gt; &quot;Player 1&quot;,
				Player::Player2 =&gt; &quot;Player 2&quot;,
			}
		)
	}
}

impl core::fmt::Display for Winner {
	fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
		write!(f, &quot;{}&quot;, self.0)
	}
}

fn main() {
	App::build()
		.add_plugins(MinimalPlugins)
		// Compound types like this are their own type, so can be fetched nicely by our scheduler
		.init_resource::&lt;HashMap&lt;Player, Score&gt;&gt;()
		.add_startup_system(initialize_scores.system())
		// By the completely unfair rules of our game, Player1 wins ties
		.add_resource(Winner(Player::Player1))
		.add_system(update_score.system())
		.add_system(determine_winner.system())
		.add_system(show_winner.system())
		.run();
}

// Rather than trying to specify a starting value at compile time, we can initialize it with its Default value
// Then we can set it within a system using more complex logic
fn initialize_scores(mut score_map: ResMut&lt;HashMap&lt;Player, Score&gt;&gt;) {
	score_map.insert(Player::Player1, Score(0));
	score_map.insert(Player::Player2, Score(0));
}

// We're modifying the score_map here, so we need to access them mutably with ResMut
// Note that we need mut in front of the parameter name as well
fn update_score(mut score_map: ResMut&lt;HashMap&lt;Player, Score&gt;&gt;) {
	let mut rng = rand::thread_rng();

	for (_, score) in score_map.iter_mut() {
		// We need to access the 0th field of our simple tuple struct Score
		*score = Score(score.0 + rng.gen_range(0..10));
	}
}

// We're only reading our score_map, but need to write to our winner parameter
fn determine_winner(score_map: Res&lt;HashMap&lt;Player, Score&gt;&gt;, mut winner: ResMut&lt;Winner&gt;) {
	// Notice how Rust automatically derefences score_map here
	// This works when we're trying to assign a resource or component to a value
	// Or when we're using a method doesn't exist on our wrapper typ
	let player_1_score = score_map.get(&amp;Player::Player1).unwrap();
	let player_2_score = score_map.get(&amp;Player::Player2).unwrap();

	// You can impl std::comp::Ord on your types to overload your comparison operators
	if player_1_score.0 &gt;= player_2_score.0 {
		// The automatic dereferencing doesn't work here, because we're trying to assign to, rather than access the value
		// So Rust can't infer what we want to do
		*winner = Winner(Player::Player1);
	} else {
		*winner = Winner(Player::Player2);
	}
}

// Finally, we just need to read the scores and winner to print them
fn show_winner(score_map: Res&lt;HashMap&lt;Player, Score&gt;&gt;, winner: Res&lt;Winner&gt;) {
	let player_1_score = score_map.get(&amp;Player::Player1).unwrap();
	let player_2_score = score_map.get(&amp;Player::Player2).unwrap();

	println!(&quot;Player 1's score: {}&quot;, player_1_score);
	println!(&quot;Player 2's score: {}&quot;, player_2_score);
	// We want to print the winner, not the reference to the winner
	println!(&quot;Right now, {} is the winner!&quot;, *winner);
}
</code></pre></pre>
<h1><a class="header" href="#control-flow-and-timing" id="control-flow-and-timing">Control Flow and Timing</a></h1>
<h1><a class="header" href="#system-scheduling-and-stages" id="system-scheduling-and-stages">System Scheduling and Stages</a></h1>
<h1><a class="header" href="#run-criteria-and-states" id="run-criteria-and-states">Run Criteria and States</a></h1>
<h1><a class="header" href="#timers-and-time-steps" id="timers-and-time-steps">Timers and Time Steps</a></h1>
<h1><a class="header" href="#tools-for-intersystem-communication" id="tools-for-intersystem-communication">Tools for Intersystem Communication</a></h1>
<p>Almost none of your systems will work in isolation. Instead, you'll want to pass data back and forth between them as your game progresses, altering the game state and advancing .</p>
<p>Bevy offers a wide array of tools you could use to do this. Here's a full list (in order of ascending complexity) and a one-sentence description of each of them, most of which are explored later in this section:</p>
<ol>
<li>Modify the same <a href="ecs/communication/../components.html">components</a>: this is your bread-and-butter for data that lives with a specific entity.</li>
<li>Modify the same <a href="ecs/communication/resources.html">resource</a>: this is the standard pattern for changing or reading persistent data that isn't attached to a specific entity.</li>
<li>Modify <a href="ecs/communication/commands.html">commands</a>: this is used to accumulate wide-ranging changes like adding entities until the end of the stage. </li>
<li>Call a second system from the first as a function like any other in Rust: can be handy if you want to repeat functionality.</li>
<li>Send <a href="ecs/communication/events.html">events</a> from one system to another: great for open-ended message passing.</li>
<li><a href="ecs/communication/chaining.html">Chain</a> one system directly into another while passing some data: handy for tightly coupled systems.</li>
</ol>
<p>While you <em>can</em> probably coerce most of these approaches to perform another's role, your code will be harder to read, harder to maintain, and very possibly less performant. Skim each of the sections linked to get a brief overview, then come back to them in detail when you need to implement that approach.</p>
<h1><a class="header" href="#commands" id="commands">Commands</a></h1>
<h1><a class="header" href="#events" id="events">Events</a></h1>
<h1><a class="header" href="#chaining-systems" id="chaining-systems">Chaining Systems</a></h1>
<h1><a class="header" href="#ecs-internals" id="ecs-internals">ECS Internals</a></h1>
<h1><a class="header" href="#app-builder" id="app-builder">App Builder</a></h1>
<h1><a class="header" href="#world" id="world">World</a></h1>
<h1><a class="header" href="#default-plugins" id="default-plugins">Default Plugins</a></h1>
<h1><a class="header" href="#archetypes" id="archetypes">Archetypes</a></h1>
<h1><a class="header" href="#reflection" id="reflection">Reflection</a></h1>
<h1><a class="header" href="#think-ecs-idiomatic-problem-solving-in-bevy" id="think-ecs-idiomatic-problem-solving-in-bevy">Think ECS: Idiomatic Problem Solving in Bevy</a></h1>
<h1><a class="header" href="#organizing-your-bevy-codebase" id="organizing-your-bevy-codebase">Organizing Your Bevy Codebase</a></h1>
<h1><a class="header" href="#project-structure" id="project-structure">Project Structure</a></h1>
<h1><a class="header" href="#plugins" id="plugins">Plugins</a></h1>
<h1><a class="header" href="#scenes" id="scenes">Scenes</a></h1>
<h1><a class="header" href="#serialization-and-networking" id="serialization-and-networking">Serialization and Networking</a></h1>
<h1><a class="header" href="#graphics" id="graphics">Graphics</a></h1>
<h1><a class="header" href="#assets-and-sprites" id="assets-and-sprites">Assets and Sprites</a></h1>
<h1><a class="header" href="#transforms" id="transforms">Transforms</a></h1>
<h1><a class="header" href="#cameras" id="cameras">Cameras</a></h1>
<h1><a class="header" href="#hierarchy-parents-and-children" id="hierarchy-parents-and-children">Hierarchy: Parents and Children</a></h1>
<h1><a class="header" href="#animation" id="animation">Animation</a></h1>
<h1><a class="header" href="#shaders" id="shaders">Shaders</a></h1>
<h1><a class="header" href="#vector-graphics" id="vector-graphics">Vector Graphics</a></h1>
<h1><a class="header" href="#user-interfaces" id="user-interfaces">User Interfaces</a></h1>
<h1><a class="header" href="#audio" id="audio">Audio</a></h1>
<h1><a class="header" href="#input" id="input">Input</a></h1>
<h1><a class="header" href="#keyboard" id="keyboard">Keyboard</a></h1>
<h1><a class="header" href="#mouse" id="mouse">Mouse</a></h1>
<h1><a class="header" href="#controller" id="controller">Controller</a></h1>
<h1><a class="header" href="#touch" id="touch">Touch</a></h1>
<h1><a class="header" href="#physics" id="physics">Physics</a></h1>
<h1><a class="header" href="#productive-development-in-bevy" id="productive-development-in-bevy">Productive Development in Bevy&quot;</a></h1>
<h1><a class="header" href="#compiling-your-game" id="compiling-your-game">Compiling Your Game</a></h1>
<h1><a class="header" href="#idiomatic-automated-testing" id="idiomatic-automated-testing">Idiomatic Automated Testing</a></h1>
<h1><a class="header" href="#diagnostics-and-debugging" id="diagnostics-and-debugging">Diagnostics and Debugging</a></h1>
<h1><a class="header" href="#cross-platform-support" id="cross-platform-support">Cross Platform Support</a></h1>
<h1><a class="header" href="#releasing-your-game" id="releasing-your-game">Releasing Your Game</a></h1>
<h1><a class="header" href="#common-issues-and-finding-help" id="common-issues-and-finding-help">Common Issues and Finding Help</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
